"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[623579],{28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var s=i(296540);const t={},a=s.createContext(t);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},899319:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"ndc/configuration/languagestemming","title":"Language Stemming","description":"Language stemming is a morphological process that converts words to their root form so that most inflected forms are considered equal. For example, an English language search for the word \\"baby\\" will also locate documents containing the word \\"babies\\".","source":"@site/docs/dataclassification/ndc/configuration/languagestemming.md","sourceDirName":"ndc/configuration","slug":"/ndc/configuration/languagestemming","permalink":"/docs/dataclassification/ndc/configuration/languagestemming","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/dataclassification/ndc/configuration/languagestemming.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dataClassificationSidebar","previous":{"title":"Core Configuration","permalink":"/docs/dataclassification/ndc/configuration/coreconfiguration"},"next":{"title":"Licensing","permalink":"/docs/dataclassification/ndc/configuration/licensing"}}');var t=i(474848),a=i(28453);const r={},c="Language Stemming",l={},o=[{value:"Supported Characters",id:"supported-characters",level:2},{value:"Supported for Diacritics (accented characters)",id:"supported-for-diacritics-accented-characters",level:2},{value:"Fuzzy Matching Options",id:"fuzzy-matching-options",level:2},{value:"Fuzzy Stemming",id:"fuzzy-stemming",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"language-stemming",children:"Language Stemming"})}),"\n",(0,t.jsx)(n.p,{children:'Language stemming is a morphological process that converts words to their root form so that most inflected forms are considered equal. For example, an English language search for the word "baby" will also locate documents containing the word "babies".'}),"\n",(0,t.jsx)(n.p,{children:"Note that the stemming process is highly language specific and so one word may stem differently in different languages."}),"\n",(0,t.jsx)(n.p,{children:"Netwrix Data Classification has support for most common languages and will detect the language for each document. However, when an index is to be built for documents in multiple languages it is normally important that the same stemmer be used for all documents. Otherwise, a search across the collection may be compromised when some words from the query are stemmed differently in different languages."}),"\n",(0,t.jsx)(n.p,{children:"If all searches are filtered by language then it may make sense to use a different stemmer for each language. However, in this case we would recommend building a separate index for each language rather than combining all languages in a single index."}),"\n",(0,t.jsx)(n.p,{children:"The reason that automatic language detection is important during the indexing process is so that the correct stoplist is used when extracting terms and concepts. By excluding words in the stoplist the index size can be significantly reduced. More importantly, the stoplists play an integral part of the concept identification process."}),"\n",(0,t.jsx)(n.p,{children:'The stemmer should be selected based on the dominant language for a given index. The default stemmer is English but this may be configured via the "StemLang" field in the "Config" table in the SQL Database.'}),"\n",(0,t.jsxs)(n.p,{children:["Netwrix Data Classification uses the stemming algorithms published as part of the Snowball project (see ",(0,t.jsx)(n.a,{href:"http://snowball.tartarus.org/",children:"http://snowball.tartarus.org"})," for details)."]}),"\n",(0,t.jsx)(n.h2,{id:"supported-characters",children:"Supported Characters"}),"\n",(0,t.jsx)(n.p,{children:"By default, the NDC database will index words containing the following characters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"a\u2013z"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"A\u2013Z"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"0\u20139"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"\u2019" (single apostrophe)'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"@"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"#"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"$"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"%"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"&"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"-" (hyphen)'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"="'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"_" (underscore)'}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Indexing of these characters can be stopped by removing the relevant entries from the CustomTermCharacters table:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"@"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"#"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"$"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"%"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"&"'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"-" (hyphen)'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"="'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'"_" (underscore)'}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Any of the following characters can be included in the list of indexed characters by adding them to the CustomTermCharacters table:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'"("'}),"\n",(0,t.jsx)(n.li,{children:'")"'}),"\n",(0,t.jsx)(n.li,{children:'"+"'}),"\n",(0,t.jsx)(n.li,{children:'"/"'}),"\n",(0,t.jsxs)(n.li,{children:['"',(0,t.jsx)(n.code,{children:"<"}),'"']}),"\n",(0,t.jsxs)(n.li,{children:['"',(0,t.jsx)(n.code,{children:">"}),'"']}),"\n",(0,t.jsx)(n.li,{children:'"["'}),"\n",(0,t.jsx)(n.li,{children:'""'}),"\n",(0,t.jsx)(n.li,{children:'"]"'}),"\n",(0,t.jsx)(n.li,{children:'"^"'}),"\n",(0,t.jsxs)(n.li,{children:['"',(0,t.jsx)(n.code,{children:"{"}),'"']}),"\n",(0,t.jsx)(n.li,{children:'"|"'}),"\n",(0,t.jsxs)(n.li,{children:['"',(0,t.jsx)(n.code,{children:"}"}),'"']}),"\n",(0,t.jsxs)(n.li,{children:['"',(0,t.jsx)(n.code,{children:"<"}),'"']}),"\n",(0,t.jsx)(n.li,{children:'"~"'}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"All other characters are mapped to spaces."}),"\n",(0,t.jsx)(n.p,{children:"Words containing characters in the CustomTermCharacters table are always index with, and also without, these characters."}),"\n",(0,t.jsx)(n.p,{children:"Therefore, a search for:"}),"\n",(0,t.jsx)(n.p,{children:'"fleur de lys"'}),"\n",(0,t.jsx)(n.p,{children:"will always match with a document containing:"}),"\n",(0,t.jsx)(n.p,{children:'"fleur-de-lys"'}),"\n",(0,t.jsx)(n.p,{children:"but not vice versa."}),"\n",(0,t.jsx)(n.p,{children:"Documents containing text in other alphabets will not be indexed correctly. In general, documents in other alphabets tend to produce \u2018noise\u2019 in the index that is largely ignored since the vast majority of indexed terms never match with a query."}),"\n",(0,t.jsx)(n.h2,{id:"supported-for-diacritics-accented-characters",children:"Supported for Diacritics (accented characters)"}),"\n",(0,t.jsx)(n.p,{children:'Netwrix Data Classification provides full support for diacritics (aka accented characters) such as: "\xe1", "\xe2", "\xe4", "\xe6" and "\xe7".'}),"\n",(0,t.jsx)(n.p,{children:"In all cases the accented characters are mapped to their closest standard letter and searches are always insensitive to diacritics, so that a search for:"}),"\n",(0,t.jsx)(n.p,{children:'"fitch\xe9e"'}),"\n",(0,t.jsx)(n.p,{children:"will match with:"}),"\n",(0,t.jsx)(n.p,{children:'"fitchee"'}),"\n",(0,t.jsx)(n.p,{children:"and vice versa."}),"\n",(0,t.jsx)(n.p,{children:"Note that this mapping of diacritics is transparent to the end user and all data displayed will always contain the original characters formats. Therefore, all document summaries, extracts and related topics will always be displayed with diacritics if the original documents contained them."}),"\n",(0,t.jsx)(n.p,{children:"In addition, all stopword processing is based on the extended ASCII character set, and so stopwords for different languages are always held with appropriate diacritics."}),"\n",(0,t.jsx)(n.h2,{id:"fuzzy-matching-options",children:"Fuzzy Matching Options"}),"\n",(0,t.jsx)(n.p,{children:"It can be useful to search for concepts using a degree of fuzzy matching so that words may be matched even if the query or documents contain typing errors or variant spelling."}),"\n",(0,t.jsx)(n.p,{children:"In general, fuzzy matching improves recall but at the expense of precision. In other words, more documents should be located but some of these may not be relevant to the query. Netwrix Data Classification offers several options for fuzzy matching so that an application can balance the needs of precision and recall."}),"\n",(0,t.jsx)(n.h3,{id:"fuzzy-stemming",children:"Fuzzy Stemming"}),"\n",(0,t.jsx)(n.p,{children:"Our stemming algorithms can optionally include a degree of fuzzy matching based on removal of duplicated consonants. The advantage of this technique is that is improves recall without any loss of precision since duplicated consonants are largely redundant in word matching. Enabling this option (set StemmingMode=1 in the Config table) will cause the following words to match:"}),"\n",(0,t.jsx)(n.p,{children:"accelerate with"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"accellerate"}),"\n",(0,t.jsx)(n.li,{children:"acelerate"}),"\n",(0,t.jsx)(n.li,{children:"acceleration"}),"\n",(0,t.jsx)(n.li,{children:"accellerator"}),"\n",(0,t.jsx)(n.li,{children:"acellerates"}),"\n",(0,t.jsx)(n.li,{children:"etc"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);