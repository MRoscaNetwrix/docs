"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[889790],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(296540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}},150346:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/recordsorigin_firstmodel-5ad1c8c1ef937ac173788d337f43447d.webp"},196497:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/recordsorigin_contexts-2660c044a74f7208c895415ac2b88499.webp"},202386:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"usercube/integration-guide/identity-management/joiners-movers-leavers/position-change/index","title":"Position Change via Records","description":"Identities\' Joiners, Movers and Leavers (JML) process can be made easy by using the adequate model: records and contexts.","source":"@site/docs/usercube_saas/usercube/integration-guide/identity-management/joiners-movers-leavers/position-change/index.md","sourceDirName":"usercube/integration-guide/identity-management/joiners-movers-leavers/position-change","slug":"/usercube/integration-guide/identity-management/joiners-movers-leavers/position-change/","permalink":"/docs/usercube_saas/usercube/integration-guide/identity-management/joiners-movers-leavers/position-change/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usercube_saas/usercube/integration-guide/identity-management/joiners-movers-leavers/position-change/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"userCubeSaasSidebar","previous":{"title":"Onboarding and Offboarding","permalink":"/docs/usercube_saas/usercube/integration-guide/identity-management/joiners-movers-leavers/on-offboarding/"},"next":{"title":"Modules","permalink":"/docs/usercube_saas/usercube/integration-guide/modules/"}}');var i=n(474848),s=n(28453);const o={},a="Position Change via Records",d={},c=[{value:"Overview",id:"overview",level:2},{value:"A Model for Identity Changes",id:"a-model-for-identity-changes",level:2},{value:"Contexts",id:"contexts",level:3},{value:"Records",id:"records",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Position Change",id:"position-change",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"position-change-via-records",children:"Position Change via Records"})}),"\n",(0,i.jsx)(t.p,{children:"Identities' Joiners, Movers and Leavers (JML) process can be made easy by using the adequate model: records and contexts."}),"\n",(0,i.jsx)(t.p,{children:"In Identity Manager, position changes are made through workflows or through synchronization to the HR system."}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"The entitlements of a user must be updated with the user's position changes: the entitlements needed for the previous position are removed, and the entitlements needed for the next position are added. This is essential to prevent users from cumulating entitlements when moving."}),"\n",(0,i.jsx)(t.p,{children:"Just like onboarding, the entitlement fulfillment can be performed either by using Identity Manager's suggestions for the needed entitlements and adjusting them, or trusting Identity Manager with an automated fulfillment."}),"\n",(0,i.jsxs)(t.p,{children:["Identity Manager's calculations for entitlement assignments rely on heuristics, through identities' key properties called ",(0,i.jsx)(t.a,{href:"/docs/usercube_saas/usercube/introduction-guide/overview/entitlement-management/",children:"\nEntitlement Management\n"}),"."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"For example, consider an entity type modeling identities with their job title, department and location."}),"\n",(0,i.jsx)(t.p,{children:"Then a user working as a accountant in Paris will receive different entitlements from another user working as a marketing specialist in Scranton."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Hence entitlement assignment is usually based on identities' positions."}),"\n",(0,i.jsx)(t.p,{children:"Within the company, an identity can hold one or several positions, sometimes several positions simultaneously."}),"\n",(0,i.jsx)(t.h2,{id:"a-model-for-identity-changes",children:"A Model for Identity Changes"}),"\n",(0,i.jsx)(t.p,{children:"Any change in an identity's lifecycle, such as a position change, usually entails a change in a given set of properties simultaneously."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"For example, a position change can typically trigger a change at least in the job title and location, together with the position start and end dates."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"It seems natural to model identities by splitting their properties into three entities: one for users' personal data, one for their contract(s) and one for their position(s):"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Records Origin - Three-Entity Model",src:n(150346).A+"",width:"2100",height:"1384"})}),"\n",(0,i.jsxs)(t.p,{children:["A user can have several positions over time, even simultaneously. A user's contract can change over time too. Even personal data is subject to change. This is why we can have several sets of personal data (and/or several contracts and/or several positions) for a single user, and also why the ",(0,i.jsx)(t.code,{children:"User"})," entity is meant to contain only users' unique identifiers."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"For example, in personal data a marriage can imply a name change, a user can start with a fixed-term contract and change to a permanent one, and position change is obvious."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Even without allowing simultaneous positions, contracts or personal data sets, this model helps anticipate upcoming changes."}),"\n",(0,i.jsx)(t.h3,{id:"contexts",children:"Contexts"}),"\n",(0,i.jsxs)(t.p,{children:["The model is supposed to facilitate the ",(0,i.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/provisioning/",children:"Provisioning"})," provisioning of user data and entitlements, yet this first model does not meet all expectations. In case of multiple personal data sets for a single user over time, or multiple contracts, or multiple positions, which values should be used to apply the rules of the role model? How to combine all start and end dates to make sure that all rules are applied based on the right input? These issues imply complex C# expressions in provisioning rules."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"For example, let's write a C# expression to compute users' display names based only on their first and last names. To make sure that display names are computed using valid input, we write the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\nC#:user:return user.PersonalDatas.Where(personalData => personalData.Start < DateTime.Now && personalData.End > DateTime.Now).Select(personalData => personalData.FirstName + ' ' + personalData.LastName).FirstOrDefault();\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now a more complex example: let's write a C# expression to compute users' departments based on their organization's display names, but also their employee identifiers in parenthesis:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'\nC#:user:return user.Positions.Where(position => position.Start < DateTime.Now && position.End > DateTime.Now).Select(position => position.Organization.DisplayName).FirstOrDefault() + " (" + user.PersonalDatas.Where(personalData => personalData.Start < DateTime.Now && personalData.End > DateTime.Now).Select(personalData => personalData.EmployeeId).FirstOrDefault() + ")";\n\n'})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:'To simplify the expressions, the model needs to be "flattened" in order to provide all the data of a given user, valid at a given date. Hence users must be modeled by a set datasheets generated by Identity Manager, where all values in one datasheet are valid on a given time period.'}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"For example, consider the following situation: Mark Barn is a user who has, at day D0, a given set of personal data, a given contract and a given position. At day D1, his contract changes from fixed-term to permanent. At day D2, he starts an additional position. The two positions overlap from day D2 to day D3 when the first position ends."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"User Example",src:n(289932).A+"",width:"4138",height:"2113"})}),"\n",(0,i.jsx)(t.p,{children:"Over time, the three entities are as follows:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Example - Timelines",src:n(324143).A+"",width:"2029",height:"1088"})}),"\n",(0,i.jsx)(t.p,{children:"From this, Identity Manager\xa0is able to combine the start and end dates of all entities at all times to generate the following datasheets, named contexts:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Example - Contexts",src:n(196497).A+"",width:"2006",height:"1204"})}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contexts are the result of the combination of all entities (personal data, contract and position) so that all values contained in a given context are valid on a given period of time."}),"\n",(0,i.jsx)(t.p,{children:"Users can be modeled by up to n*n*n contexts, and even more when elements overlap (positions in this example)."}),"\n",(0,i.jsx)(t.p,{children:"The complexity that comes from the combination of all start and end dates is tackled by Identity Manager's engine when it generates users' contexts. As the start and end dates of each value are pre-computed by Identity Manager, this user model highly simplifies provisioning rules."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"The C# expressions from the previous example can be written, for the same result, as the following, first for users' display names, then departments:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"\nC#:record:return record.FirstName + ' ' + record.LastName;\n\n"})}),"\n",(0,i.jsxs)(t.p,{children:["C#:record",":return",' record.Organization.DisplayName + " (" + record.EmployeeId + ")";']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{})}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"records",children:"Records"}),"\n",(0,i.jsx)(t.p,{children:"The final step to a viable model is to find a way to store optimally this context model in the database, in order to be able to perform fast requests. Hence, the final model gathers all entities (personal data, contracts and positions), including their respective start and end dates, into a single entity named records, where a context is a record instance:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Records Origin - Final Model",src:n(346643).A+"",width:"1659",height:"468"})}),"\n",(0,i.jsx)(t.p,{children:"While there are as many contexts for a user as the number of changes in the user's datasheet, there are only as many records as needed to store each value at least once."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["With the example used for the explanation of contexts with ",(0,i.jsx)(t.code,{children:"PD"}),", ",(0,i.jsx)(t.code,{children:"C1"}),", ",(0,i.jsx)(t.code,{children:"C2"}),", ",(0,i.jsx)(t.code,{children:"P1"})," and ",(0,i.jsx)(t.code,{children:"P2"}),", we generate 5 contexts but store only 2 records: ",(0,i.jsx)(t.code,{children:"{PD; C1; P1}"})," and ",(0,i.jsx)(t.code,{children:"{PD; C2; P2}"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"From these 2 records, we can rebuild the 5 contexts."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contexts can be considered as the conversion tool between the two user models."}),"\n",(0,i.jsx)(t.p,{children:"This way, the model stores only Max(n) records instead of n*n*n."}),"\n",(0,i.jsx)(t.p,{children:"Plus, Identity Manager\xa0does not need to archive old data, because records and contexts are used only to simplify the application of provisioning rules. As only valid values are provisioned, there is no need to keep track."}),"\n",(0,i.jsx)(t.p,{children:"This means that a change to be effective immediately will not trigger the creation of a new record nor a new context. The record containing the old data will simply be updated."}),"\n",(0,i.jsx)(t.p,{children:"A change to be effective in future can trigger the creation of a new record."}),"\n",(0,i.jsx)(t.h3,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(t.p,{children:["This identity model can be implemented by configuring a ",(0,i.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/contextrule/",children:"\nContext Rule\n"})," and ",(0,i.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection/",children:"\nRecord Section\n"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'\n```<ContextRule Identifier="Directory_User" DisplayName_L1="Directory_User" Policy="Default" SourceEntityType="Directory_User" ResourcesBinding="Records" ResourcesStartExpression="C#:record:return record.StartDate ?? record.PositionStartDate ?? record.ContractStartDate;" ResourcesEndExpression="C#:record:return record.EndDate ?? record.PositionEndDate ?? record.ContractEndDate;" ExcludeExpression="C#:record:return record.IsDraft.GetValueOrDefault();" RiskFactorType="Max"\n    B0="Directory_UserRecord:Organization"\n    B1="Directory_UserRecord:Title"\n    B2="Directory_UserRecord:Site"\n    B3="Directory_UserRecord:Site.Region.Country"\n    B4="Directory_UserRecord:UserType.Category"\n    B5="Directory_UserRecord:Organization.Type"\n    B6="Directory_UserRecord:Subsidiary"\n    B7="Directory_UserRecord:ExternalCompany"\n/>```\n\nPersonal data section (default section):\n<RecordSection Identifier="Directory_UserRecord_Default" DisplayName_L1="User Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="StartDate" EndProperty="EndDate" InstanceKeyExpression="C#:record:return record.StartDate.HasValue ? record.StartDate.Value.ToString("yyyyMMdd") : string.Empty;"></RecordSection>\n\nContract section:\n<RecordSection Identifier="Directory_UserRecord_Contract" DisplayName_L1="Contract Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="ContractStartDate" EndProperty="ContractEndDate" IsDefaultBoundariesSection="true" InstanceKeyExpression="C#:record:return record.ContractIdentifier;">  ```<Property Property="UserType"/>```  ```<Property Property="ExternalCompany"/>```  ```<Property Property="Subsidiary"/>```</RecordSection>\n\nPosition section:\n<RecordSection Identifier="Directory_UserRecord_Position" DisplayName_L1="Position Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="PositionStartDate" EndProperty="PositionEndDate" InstanceKeyExpression="C#:record:return record.PositionIdentifier;">  ```<Property Property="PositionIdentifier" />```  ```<Property Property="JobTitle" />```  ```<Property Property="OfficeNumber" />```  ```<Property Property="Organization" />```  ```<Property Property="Site"/>```  ```<Property Property="Title" />```  ```<Property Property="Office" />```  ```<Property Property="Manager" />```  ```<Property Property="IGAManager" />```  ```<Property Property="EffectiveIGAManager" />```  ```<Property Property="IsMainPosition" />```</RecordSection>\n\n'})}),"\n",(0,i.jsx)(t.h2,{id:"position-change",children:"Position Change"}),"\n",(0,i.jsx)(t.p,{children:"The position change process for an existing worker is materialized by the assignment/update/removal of a record to/from an identity. This assignment/update/removal triggers the fulfillment of the entitlements required by the user based on the properties of a valid record."}),"\n",(0,i.jsx)(t.p,{children:"When several contexts are valid at the same time for a given identity, conflicts can arise during entitlement assignment. They are solved by Identity Manager's engine that establishes a priority between valid contexts."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},289932:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/recordsorigin_userexample-341a4c3aa1d2752d5e17803df147ba3f.webp"},324143:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/recordsorigin_timelines-bec9d39383048ff08d33a0002b48b9c2.webp"},346643:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/recordsorigin_thirdmodel-7deff92927f9cca138c1f6af90e3e9ae.webp"}}]);