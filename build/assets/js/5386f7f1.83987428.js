"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[765855],{28453:(e,t,r)=>{r.d(t,{R:()=>s,x:()=>c});var n=r(296540);const o={},i=n.createContext(o);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(i.Provider,{value:t},e.children)}},202332:(e,t,r)=>{r.d(t,{A:()=>n});const n=r.p+"assets/images/recordsection_extensionkind-c230c95b0e784fca30657f689de8f20d.webp"},850823:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection/index","title":"Record Section","description":"Record sections shape identity data for a given entity type, by grouping properties into sections, for example personal data, contract or position.","source":"@site/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection/index.md","sourceDirName":"usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection","slug":"/usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection/","permalink":"/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/recordsection/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"userCubeSaasSidebar","previous":{"title":"Policy","permalink":"/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/policy/"},"next":{"title":"Resource Classification Rule","permalink":"/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/resourceclassificationrule/"}}');var o=r(474848),i=r(28453);const s={},c="Record Section",d={},a=[{value:"Examples",id:"examples",level:2},{value:"InstanceKeyExpression",id:"instancekeyexpression",level:3},{value:"IsDefaultBoundariesSection",id:"isdefaultboundariessection",level:3},{value:"Context extension",id:"context-extension",level:3},{value:"Properties",id:"properties",level:2},{value:"Child Element: Property",id:"child-element-property",level:2},{value:"Examples",id:"examples-1",level:3},{value:"Properties",id:"properties-1",level:3}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"record-section",children:"Record Section"})}),"\n",(0,o.jsx)(t.p,{children:"Record sections shape identity data for a given entity type, by grouping properties into sections, for example personal data, contract or position."}),"\n",(0,o.jsx)(t.p,{children:"Record sections impact the generation of identities' contexts which contain users' dimension values valid on a given period of time. The aim is to simplify the application of the role model' rules for provisioning."}),"\n",(0,o.jsx)(t.p,{children:"Thanks to this data organization in sections, the identities of a given entity type can be modeled by more than one context over time, even simultaneously. This means that users can have more than one contract, or position, at a time, and that data changes can be anticipated."}),"\n",(0,o.jsxs)(t.p,{children:["See the ",(0,o.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/identity-management/joiners-movers-leavers/position-change/",children:"\nPosition Change via Records\n"}),"for additional information on identity modeling."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Configuration recommendations:"})}),"\n",(0,o.jsxs)(t.p,{children:["As record sections cannot be configured without a ",(0,o.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/toolkit/xml-configuration/provisioning/contextrule/",children:"\nContext Rule\n"}),", Netwrix Identity Manager (formerly Usercube) recommends starting with the configuration of the context rule before configuring record sections."]}),"\n",(0,o.jsx)(t.p,{children:"Netwrix Identity Manager (formerly Usercube)recommends defining at least two record sections: a default section for the properties shared by all records, and another section for a given set of properties which differentiate between records. The default section must contain zero properties, the shared properties are those that are not defined in the other section(s)."}),"\n",(0,o.jsx)(t.p,{children:"For example, to model several positions for a single user, we configure the default record section to contain the properties shared by all positions such as personal data, and we configure the position section to contain the properties specific to each position. Similar to the position section, we can also typically configure a section for contracts."}),"\n",(0,o.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsxs)(t.p,{children:["The following example models users from the ",(0,o.jsx)(t.code,{children:"Directory_User"})," entity type with three sets of properties: user properties, contract properties and position properties. All created records will be resources from the ",(0,o.jsx)(t.code,{children:"Directory_UserRecord"})," entity type."]}),"\n",(0,o.jsxs)(t.p,{children:["The properties from the contract (or position) section are the properties specific to each contract (or position). The properties from ",(0,o.jsx)(t.code,{children:"Directory_User"})," that are not specified in the record sections are the properties shared between all records, here user properties."]}),"\n",(0,o.jsx)(t.p,{children:"Each section must be defined with start and end dates, so that Identity Manager's engine is able to combine all periods of validity and apply the rules with the right input at any time."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'\nDefault section:\n<RecordSection Identifier="Directory_UserRecord_Default" DisplayName_L1="User Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="StartDate" EndProperty="EndDate"> ...\n</RecordSection>\n\nContract section:\n<RecordSection Identifier="Directory_UserRecord_Contract" DisplayName_L1="Contract Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="ContractStartDate" EndProperty="ContractEndDate"> ...\n  <Property Property="UserType"/>  <Property Property="ExternalCompany"/>  <Property Property="Subsidiary"/></RecordSection>\n\nPosition section:\n<RecordSection Identifier="Directory_UserRecord_Position" DisplayName_L1="Position Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="PositionStartDate" EndProperty="PositionEndDate"> ...\n  <Property Property="PositionIdentifier" />  <Property Property="JobTitle" />  <Property Property="OfficeNumber" />  <Property Property="Organization" />  <Property Property="Site"/>  <Property Property="Title" />  <Property Property="Office" />  <Property Property="Manager" />  <Property Property="IGAManager" />  <Property Property="EffectiveIGAManager" />  <Property Property="IsMainPosition" /></RecordSection>\n\n'})}),"\n",(0,o.jsx)(t.h3,{id:"instancekeyexpression",children:"InstanceKeyExpression"}),"\n",(0,o.jsx)(t.p,{children:"The following example computes a unique key for each record section instance. This way, we can distinguish between contracts thanks to their identifiers, same for positions, and between user property sets thanks to a C# expression based on the start date."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'\nDefault section:\n<RecordSection Identifier="Directory_UserRecord_Default" DisplayName_L1="User Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="StartDate" EndProperty="EndDate" InstanceKeyExpression="C#:record:return record.StartDate.HasValue ? record.StartDate.Value.ToString("yyyyMMdd") : string.Empty;"></RecordSection>\n\nContract section:\n<RecordSection Identifier="Directory_UserRecord_Contract" DisplayName_L1="Contract Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="ContractStartDate" EndProperty="ContractEndDate" InstanceKeyExpression="C#:record:return record.ContractIdentifier;">  <Property Property="UserType"/>  ...\n</RecordSection>\n\nPosition section:\n<RecordSection Identifier="Directory_UserRecord_Position" DisplayName_L1="Position Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="PositionStartDate" EndProperty="PositionEndDate" InstanceKeyExpression="C#:record:return record.PositionIdentifier;">  <Property Property="PositionIdentifier" />  ...\n</RecordSection>\n\n'})}),"\n",(0,o.jsx)(t.p,{children:"An instance key is required when we need to uniquely identify a context, i.e. when we may have several simultaneous contexts."}),"\n",(0,o.jsx)(t.p,{children:"For example, an instance key is required for the position section when users can have overlapping positions."}),"\n",(0,o.jsx)(t.h3,{id:"isdefaultboundariessection",children:"IsDefaultBoundariesSection"}),"\n",(0,o.jsxs)(t.p,{children:["The following example uses the contract start/end dates as default boundaries in users' validity period, instead of those from the default section. See the ",(0,o.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/identity-management/joiners-movers-leavers/on-offboarding/",children:"\nOnboarding and Offboarding\n"})," topic for additional information. It may be because, for example, HR services do not enter an end date for the personal data of users on permanent contracts. So we prefer to use the start and end dates of their contracts."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'\nContract section:\n<RecordSection Identifier="Directory_UserRecord_Contract" DisplayName_L1="Contract Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="ContractStartDate" EndProperty="ContractEndDate" IsDefaultBoundariesSection="true">  <Property Property="UserType"/>  ...\n</RecordSection>\n\n'})}),"\n",(0,o.jsx)(t.h3,{id:"context-extension",children:"Context extension"}),"\n",(0,o.jsx)(t.p,{children:"There can be some time gap where no context is defined, for example a time gap with a position but no contract or vice versa. Identity Manager offers the possibility to choose whether an existing context is to be extended to the period without context. And in case we decide to use another context and extend its values, which context should it be?"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Schema - ExtensionKind",src:r(202332).A+"",width:"2033",height:"881"})}),"\n",(0,o.jsxs)(t.p,{children:["Here, we decide to extend an existing contract to the gap, for example because users' email addresses are built using the contract type to add ",(0,o.jsx)(t.code,{children:"-ext"})," for external users. And we decide to not extend the position."]}),"\n",(0,o.jsxs)(t.p,{children:["In the following example, the contract section uses ",(0,o.jsx)(t.code,{children:"SortKeyExpression"})," to establish between existing contracts a priority order that will determine which contract should be extended to the gap. Based on this C# expression that returns a value ",(0,o.jsx)(t.code,{children:"A"}),", ",(0,o.jsx)(t.code,{children:"B"})," or ",(0,o.jsx)(t.code,{children:"C"}),", the ",(0,o.jsx)(t.code,{children:"ExtendedSortKey"})," considers as extendable only the contract(s) whose expression returns ",(0,o.jsx)(t.code,{children:"C"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The position section uses ",(0,o.jsx)(t.code,{children:"ExtensionKind"})," set to ",(0,o.jsx)(t.code,{children:"None"})," to block the extension mechanism."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'\nContract section:\n<RecordSection Identifier="Directory_UserRecord_Contract" DisplayName_L1="Contract Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="ContractStartDate" EndProperty="ContractEndDate" SortKeyExpression="C#:record:return record.Main.GetValueOrDefault() && record.UserType.Id == -018 ? "C" : (!record.Main.GetValueOrDefault() && record.UserType.Id == -018 ? "B" : "A");" ExtendedSortKey="C">  <Property Property="UserType"/>  ...\n</RecordSection>\n\nPosition section:\n<RecordSection Identifier="Directory_UserRecord_Position" DisplayName_L1="Position Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="PositionStartDate" EndProperty="PositionEndDate" ExtensionKind="None">  <Property Property="PositionIdentifier" />  ...\n</RecordSection>\n\n'})}),"\n",(0,o.jsx)(t.p,{children:"When not specifying any sort key nor extended sort key, Identity Manager\xa0will select a context to extend to the gap. However, it may not be functionally the most meaningful context."}),"\n",(0,o.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{children:"Property"}),(0,o.jsx)(t.th,{children:"Details"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"BoundaryKind   default value: 0"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    RecordBoundaryKind   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Defines how the section dates are computed for a resource, when the current start/end dates are null.   ",(0,o.jsx)(t.code,{children:"0"})," - None: start date and end date are equal respectively to the minimum value of ",(0,o.jsx)(t.code,{children:"StartProperty"})," and maximum value of ",(0,o.jsx)(t.code,{children:"EndProperty"})," when comparing the default sections of all records.   ",(0,o.jsx)(t.code,{children:"1"})," - Kept: start and end dates are equal respectively to the default start date (1900/01/01 00:00:00) and end date (2079/06/06 00:00:00).   ",(0,o.jsx)(t.strong,{children:"Info:"})," the boundary has no effect on the default section which is the reference to compute the default dates in other sections. When the default section's start/end dates are null, then they equal the default start/end dates."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"DisplayName_L1   required"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    String   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Display name of the section in language 1 (up to 16)."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"EndProperty   optional"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Int64   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Date property among those from the ",(0,o.jsx)(t.code,{children:"ResourceEntityType"})," which specifies the end of validity for all the ",(0,o.jsx)(t.a,{href:"#Record-Section",children:" Record Section "})," of the section. It cannot be a property computed by an ",(0,o.jsx)(t.code,{children:"EntityPropertyExpression"}),"."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"ExtendedSortKey   optional"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    String   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Value used as a threshold for ",(0,o.jsx)(t.code,{children:"SortKeyExpression"})," values to determine whether the ",(0,o.jsx)(t.a,{href:"#Record-Section",children:" Record Section "})," property values of a given record section can be extended from a context where the values are defined to another context where no properties from the section are defined.   This extension is enabled only when the value of ",(0,o.jsx)(t.code,{children:"SortKeyExpression"})," of the section is higher (with an ordinal comparison) than ",(0,o.jsx)(t.code,{children:"ExtendedSortKey"}),"."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"ExtensionKind   default value: 0"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    RecordExtensionKind   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Defines whether the section's property values can be extended (copied) from a context where the properties are defined to another context where no properties from the section are defined.   ",(0,o.jsx)(t.code,{children:"0"})," - Default: the section's property values can be extended.   ",(0,o.jsx)(t.code,{children:"4"})," - None: the section's property values cannot be extended."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Identifier   required"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    String   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Unique identifier of the section."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"InstanceKeyExpression   optional"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    String   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Expression returning a key to uniquely identify a context, i.e. distinguish between job positions for example when users can have several concurrent positions, or between contracts. See the ",(0,o.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/toolkit/expressions/",children:"Expressions"})," topic for additional information."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"IsDefaultBoundariesSection   default value: false"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Boolean   ",(0,o.jsx)(t.strong,{children:"Description"}),"   ",(0,o.jsx)(t.code,{children:"true"})," to use the start/end dates of this section as the default boundaries, i.e. the start/end dates of users' validity period. When no section has ",(0,o.jsx)(t.code,{children:"IsDefaultBoundaries"})," set to ",(0,o.jsx)(t.code,{children:"true"}),", the default section (the one without properties) is automatically selected."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"ResourceEntityType   required"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Int64   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Identifier of the entity type of the multiple records to be created."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SortKeyExpression   optional"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    String   ",(0,o.jsx)(t.strong,{children:"Description"}),"   C# expression used to compute a value for each record, to be used as a priority, following an ordinal comparison. See the ",(0,o.jsx)(t.a,{href:"/docs/usercube_saas/usercube/integration-guide/toolkit/expressions/",children:"Expressions"})," topic for additional information.   When a record section has ",(0,o.jsx)(t.code,{children:"ExtensionKind"})," set to ",(0,o.jsx)(t.code,{children:"Default"})," and a priority value higher than ",(0,o.jsx)(t.code,{children:"ExtendedSortKey"}),", then the record property values can be extended from a context where the values are defined to another context where no properties from the section are defined."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"SourceEntityType   required"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Int64   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Identifier of the entity type of the parent resource."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"StartProperty   optional"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Int64   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Date property among those from the ",(0,o.jsx)(t.code,{children:"ResourceEntityType"})," which specifies the beginning of validity for all he ",(0,o.jsx)(t.a,{href:"#Record-Section",children:" Record Section "})," properties of the section. It cannot be a property computed by an ",(0,o.jsx)(t.code,{children:"EntityPropertyExpression"}),"."]})]})]})]}),"\n",(0,o.jsx)(t.h2,{id:"child-element-property",children:"Child Element: Property"}),"\n",(0,o.jsx)(t.p,{children:"A record section is a set of record properties which belong to the resource entity type."}),"\n",(0,o.jsx)(t.h3,{id:"examples-1",children:"Examples"}),"\n",(0,o.jsxs)(t.p,{children:["In the following example, the position section gathers the properties ",(0,o.jsx)(t.code,{children:"Organization"}),", ",(0,o.jsx)(t.code,{children:"Location"})," and ",(0,o.jsx)(t.code,{children:"Title"}),", while the default section gathers all the other properties from ",(0,o.jsx)(t.code,{children:"Directory_UserRecord"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The property ",(0,o.jsx)(t.code,{children:"Location"})," can be extended from a context where the location is defined to a context where it is not. The two other properties cannot be extended."]}),"\n",(0,o.jsxs)(t.p,{children:["See the ",(0,o.jsx)(t.a,{href:"#Record-Section",children:"\nRecord Section\n"})," topic for additional information."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'\nDefault section:\n<RecordSection Identifier="Directory_UserRecord_Default" DisplayName_L1="Contract Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="ContractStartDate" EndProperty="ContractEndDate">\n</RecordSection>\n\nPosition section:\n<RecordSection Identifier="Directory_UserRecord_Position" DisplayName_L1="Position Properties" SourceEntityType="Directory_User" ResourceEntityType="Directory_UserRecord" StartProperty="StartDate" EndProperty="EndDate">\n    <Property Property="Organization" ExtensionKind="None" />    <Property Property="Location"/>    <Property Property="Title" ExtensionKind="None" />\n</RecordSection>\n\n'})}),"\n",(0,o.jsx)(t.h3,{id:"properties-1",children:"Properties"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{children:"Property"}),(0,o.jsx)(t.th,{children:"Details"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"ExtensionKind   default value: 0"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    RecordExtensionKind   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Defines whether the property value can be extended (copied) from a context where the section properties are defined to another context where no properties from the section are defined.   ",(0,o.jsx)(t.code,{children:"0"})," - Default: the property value can be extended.   ",(0,o.jsx)(t.code,{children:"4"})," - None: the property value cannot be extended.   ",(0,o.jsx)(t.strong,{children:"Note:"})," a property value can be extended only if the section is extendable too."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"IsExcluded   default value: false"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Boolean   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Excludes the given property from the section. This is used only in the default section to remove properties such as the RecordIdentifier that are always different between all the records and that are thus not interesting for the provisioning rules."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"Property   required"}),(0,o.jsxs)(t.td,{children:[(0,o.jsx)(t.strong,{children:"Type"}),"    Int64   ",(0,o.jsx)(t.strong,{children:"Description"}),"   Identifier of the property from the record section's ",(0,o.jsx)(t.code,{children:"ResourceEntityType"})," that is to be part of the section."]})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);