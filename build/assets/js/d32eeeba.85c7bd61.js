"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[233442],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>s});var a=n(296540);const o={},r=a.createContext(o);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(r.Provider,{value:t},e.children)}},945953:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"policypak/license/mdm/tool","title":"I\'m having trouble running the Licensing Tool (LT) and counting computers with Intune. What troubleshooting information can I send Endpoint Policy Manager support?","description":"Please run the following commands in an elevated powershell and supply the resulting screenshots or Output.txt file.","source":"@site/docs/policypak/policypak/license/mdm/tool.md","sourceDirName":"policypak/license/mdm","slug":"/policypak/license/mdm/tool","permalink":"/docs/policypak/policypak/license/mdm/tool","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/policypak/policypak/license/mdm/tool.md","tags":[],"version":"current","frontMatter":{},"sidebar":"policyPakSidebar","previous":{"title":"When licensing Endpoint Policy Managerwith an MDM provider, what do I need to send in to Endpoint Policy Manager?","permalink":"/docs/policypak/policypak/license/mdm/setup"},"next":{"title":"Knowledge Base","permalink":"/docs/policypak/policypak/license/overview/knowledgebase"}}');var o=n(474848),r=n(28453);const i={},s="I'm having trouble running the Licensing Tool (LT) and counting computers with Intune. What troubleshooting information can I send Endpoint Policy Manager support?",c={},l=[];function u(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"im-having-trouble-running-the-licensing-tool-lt-and-counting-computers-with-intune-what-troubleshooting-information-can-i-send-endpoint-policy-manager-support",children:"I'm having trouble running the Licensing Tool (LT) and counting computers with Intune. What troubleshooting information can I send Endpoint Policy Manager support?"})}),"\n",(0,o.jsx)(t.p,{children:"Please run the following commands in an elevated powershell and supply the resulting screenshots or Output.txt file."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"function Get-MgGraphAllPages {  \n\xa0\xa0\xa0\xa0[CmdletBinding(  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ConfirmImpact = 'Medium',  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0DefaultParameterSetName = 'SearchResult'  \n\xa0\xa0\xa0\xa0)]  \n\xa0\xa0\xa0\xa0param (  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[Parameter(Mandatory = $true, ParameterSetName = 'NextLink', ValueFromPipelineByPropertyName = $true)]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[ValidateNotNullOrEmpty()]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[Alias('@odata.nextLink')]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[string]$NextLink  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0,  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[Parameter(Mandatory = $true, ParameterSetName = 'SearchResult', ValueFromPipeline = $true)]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[ValidateNotNull()]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[PSObject]$SearchResult  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0,  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[Parameter(Mandatory = $false)]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[switch]$ToPSCustomObject  \n\xa0\xa0\xa0\xa0)\xa0  \n\xa0\xa0\xa0\xa0begin {}\xa0  \n\xa0\xa0\xa0\xa0process {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($PSCmdlet.ParameterSetName -eq 'SearchResult') {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Set the current page to the search result provided  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$page = $SearchResult\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Extract the NextLink  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$currentNextLink = $page.'@odata.nextLink'\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# We know this is a wrapper object if it has an \"@odata.context\" property  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0#if (Get-Member -InputObject $page -Name '@odata.context' -Membertype Properties) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# MgGraph update - MgGraph returns hashtables, and almost always includes .context  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# instead, let's check for nextlinks specifically as a hashtable key  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($page.ContainsKey('@odata.count')) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Write-Verbose \"First page value count: $($Page.'@odata.count')\"\xa0\xa0\xa0\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($page.ContainsKey('@odata.nextLink') -or $page.ContainsKey('value')) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values = $page.value  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} else { # this will probably never fire anymore, but maybe.  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values = $page  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Output the values  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Default returned objects are hashtables, so this makes for easy pscustomobject conversion on demand  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($values) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($ToPSCustomObject) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values | ForEach-Object {[pscustomobject]$_}\xa0\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} else {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values | Write-Output  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0while (-Not ([string]::IsNullOrWhiteSpace($currentNextLink)))  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0{  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Make the call to get the next page  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0try {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$page = Invoke-MgGraphRequest -Uri $currentNextLink -Method GET  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} catch {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0throw $_  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Extract the NextLink  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$currentNextLink = $page.'@odata.nextLink'\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Output the items in the page  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values = $page.value\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($page.ContainsKey('@odata.count')) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Write-Verbose \"Current page value count: $($Page.'@odata.count')\"\xa0\xa0\xa0\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0# Default returned objects are hashtables, so this makes for easy pscustomobject conversion on demand  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if ($ToPSCustomObject) {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values | ForEach-Object {[pscustomobject]$_}\xa0\xa0  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0} else {  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0$values | Write-Output  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}  \n\xa0\xa0\xa0\xa0}\xa0  \n\xa0\xa0\xa0\xa0end {}  \n}  \n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12  \nInstall-PackageProvider -Name NuGet -Scope CurrentUser -Force  \nInstall-Module -Name Microsoft.Graph.Authentication -Repository PSGallery -Scope CurrentUser -Force  \nInstall-Module -Name Microsoft.Graph.Identity.DirectoryManagement -Repository PSGallery -Scope CurrentUser -Force  \nInstall-Module -Name Microsoft.Graph.DeviceManagement -Repository PSGallery -Scope CurrentUser -Force  \nConnect-MgGraph -Scopes \"DeviceManagementManagedDevices.Read.All\", \"Organization.Read.All\" -NoWelcome  \nGet-MgOrganization | Select @{N = 'CompanyName'; E = { $_.displayName } }  \n[array]$devices = Get-MgDeviceManagementManagedDevice | Get-MgGraphAllPages | Where-Object -Property \"operatingSystem\" -EQ -Value \"Windows\" | ForEach { [pscustomobject] @{ DeviceName= $_.deviceName; UPN = $_.userPrincipalName; UPNDomain = $_.userPrincipalName.Split(\"@\")[1]}}  \n[array]$upns = $devices | Where-Object -Property 'UPNDomain' -NE -Value $null | Select-Object -Property 'UPNDomain' -Unique  \n# Output to both screen and file  \n$outputFile = \"OUTPUT.TXT\"  \n# Function to output to both  \nfunction Out-Both {  \n\xa0\xa0\xa0\xa0param (  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[Parameter(Mandatory=$true)]  \n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[string]$message  \n\xa0\xa0\xa0\xa0)  \n\xa0\xa0\xa0\xa0$message | Tee-Object -FilePath $outputFile -Append  \n}  \n# Clear the output file if it exists  \nif (Test-Path $outputFile) {  \n\xa0\xa0\xa0\xa0Remove-Item $outputFile  \n}  \n# Write the results  \n$upns | Format-Table | Out-Both  \n$devices | Format-Table -Property 'DeviceName' | Out-Both  \nOut-Both \"\"  \nOut-Both \"Total\"  \nOut-Both \"-----\"  \nOut-Both @($devices).Count  \nDisconnect-MgGraph | Out-Null\n"})}),"\n",(0,o.jsxs)(t.p,{children:["See the ",(0,o.jsx)(t.a,{href:"/docs/policypak/policypak/video/license/mdm",children:"MDM Intune company name troubleshooting"})," video for additional information."]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);